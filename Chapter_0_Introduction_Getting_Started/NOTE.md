# 0.1 - Welcome

# 0.2 - Introduction to programming languages

## Machine Language
- Composed of binary i.e. 10110000

## Assembly Language
- invented to compensate for a readability issue of machine language. Translated via _assembler_ program for a machine to understand.
- Very fast but 1. requires lots of instructions for a simple task. 2. not portable

## High-level languages
- Address _readability_ and _portability_ concerns. i.e. C, C++, Pascal (later like Java, Perl)
- Requires _compiling_ and _interpreting_, requiring a *compiler* and *interpreter*
- Compiler
    - Compiling process: High-level language source code -> compiled by a Compiler -> producing Executable -> runs on Hardware -> produces Program results
- Interpreter
    - Directly executes the instructions in the source code withoutt requiring them to be compiled into an executable.
    - Interpretation process: High-level language code -> interpreted by Interpreter -> runs on Hardware -> produces Program results

# 0.3 - Introduction to C/C++

- Q. What is C++ good at?
- A. C++ excels in situations where high performance and precise control over memory and other resources is needed.
    - Video games
    - Real-time systems(e.g. for transportation, manufacturing, etc...)
    - High-performace financial applications(e.g. high frequency trading)
    - Graphical applications and simulations
    - Productivity / office applications
    - Embedded software
    - Audio and video processing
    - Artificial intelligence and neural networks

# 0.4 - Introduction to C++ development

* Program development
1) Define the problem to solve
2) Design a solution
3) Write a program that implements the solution
4) Compile the program
5) Link object files
6) Test program
7) Debug (go back to #4)

Step 1: "What" step (What is the problem that you would like to solve)

Step 2: "How" step (How you are going to solve the problem)
- Good solutions
    - Strightforward
    - well documented
    - built modularly, so parts can be reused or changed later without impacting other parts of the program.
    - robust, and can recover or give useful error messages when something unexpected happens.

- Spend a little extra time up front (before start coding) thinking about the best way to tackle a problem, what assumptions you are making, and how you might plan for the future, in order to save yourself a lot of time and trouble down the road.

Step 3: "Write" step

# 0.5 - Introduction to the compiler, linker, and libraries

Step 4: "Compiling" source code
- translates ***source code***(_name.cpp_ file) into ***object file***(_name.o_ file)

Step 5: Linking object files and libraries
- take all object files generated by the compiler and combine them into a single executable program.

Step 6 & 7: Testing and Debugging

# 0.6 - Installing an Integrated Development Environment (IDE)

# 0.7 - Compiling your first program

- HelloWorld.cpp

# 0.8 - A few common C++ problems

# 0.9 - Configuring your compiler: Build configurations

# 0.10 - Configuring your compiler: Compiler extensions
